/**
 * 给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。


示例 1：

输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
示例 2：

输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
*/

/**
 * @param {number} n
 * @return {number[]}
 */

// 因为需要计算转换为二进制后，1的个数
// 如果是2的幂，那么1肯定只有 1个，如：01 10 100 1000 10000
// 如果非2的次幂，如【100,1000】区间的 101、110、111。如何获取它们的状态方程才是需要考虑的
// 我们设置一个数y, 发现d[i] = d[i - y] + 1, 其中的y必须是2的幂
// 如果i是2的次幂，那么i === y,唯一要做的就是每次更新y的值

var countBits = function (n) {
    const bits = Array(n + 1).fill(0)
    let y = 0
    for (let i = 1; i <= n; i++) {
        if ((i & (i - 1)) === 0) {
            y = i
        }
        bits[i] = bits[i - y] + 1
    }
    return bits
};

// 官方题解
/**
 * 方法二需要实时维护最高有效位，当遍历到的数是 2 的整数次幂时，需要更新最高有效位。如果再换一个思路，可以使用「最低有效位」计算「一比特数」。

对于正整数 x，将其二进制表示右移一位，等价于将其二进制表示的最低位去掉，得到的数是[x/2]
。如果 bits[x/2]的值已知，则可以得到 bits[x] 的值：
    如果 x 是偶数，则 bits[x]=bits[x/2]
    如果 x 是奇数，则 bits[x]=bits[x/2]+1。

上述两种情况可以合并成：bits[x] 的值等于 bits[x/2]的值加上 x 除以 2 的余数。

由于[x/2] 可以通过 x>>1 得到，x 除以 2 的余数可以通过 x & 1 得到，因此有：bits[x]=bits[x>>1]+(x&1)。
遍历从 1 到 n 的每个正整数 i，计算 bits 的值。最终得到的数组 bits 即为答案。
*/

var countBits = function(n) {
    const bits = new Array(n + 1).fill(0);
    for (let i = 1; i <= n; i++) {
        bits[i] = bits[i >> 1] + (i & 1);
    }
    return bits;
};
